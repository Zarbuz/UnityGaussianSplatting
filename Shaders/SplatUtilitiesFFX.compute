// SPDX-License-Identifier: MIT
#define GROUP_SIZE 1024

#pragma kernel CSSetIndices
#pragma kernel CSCalcDistances
#pragma kernel CSCalcViewData

// Frustum culling kernels
#pragma kernel CSCullChunks
#pragma kernel CSCullSplatsInPartialChunks
#pragma kernel CSStreamCompactScan
#pragma kernel CSStreamCompactWrite

// LOD (Level of Detail) kernels based on LODGE paper
#pragma kernel CSUpdateLODSelection

#include "GpuSortFidelityFX.hlsl"

// FidelityFX GPU sorting
#pragma kernel FfxParallelSortReduce
#pragma kernel FfxParallelSortScanAdd
#pragma kernel FfxParallelSortScan
#pragma kernel FfxParallelSortScatter
#pragma kernel FfxParallelSortCount
#include "GaussianSplatting.hlsl"
#include "UnityCG.cginc"

float4x4 _MatrixObjectToWorld;
float4x4 _MatrixWorldToObject;
float4x4 _MatrixMV;
float4x4 _MatrixP;
float4 _VecScreenParams;
float4 _VecWorldSpaceCameraPos;
int _SelectionMode;

RWStructuredBuffer<uint> _SplatSortDistances;
RWStructuredBuffer<uint> _SplatSortKeys;
uint _SplatCount;

// radix sort etc. friendly, see http://stereopsis.com/radix.html
uint FloatToSortableUint(float f)
{
    uint fu = asuint(f);
    uint mask = -((int)(fu >> 31)) | 0x80000000;
    return fu ^ mask;
}

[numthreads(GROUP_SIZE,1,1)]
void CSSetIndices(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    _SplatSortKeys[idx] = idx;
}

[numthreads(GROUP_SIZE,1,1)]
void CSCalcDistances(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    uint origIdx = _SplatSortKeys[idx];

    // Check for sentinel values (unused entries from frustum culling)
    if (origIdx >= 0xFFFFFFF0)
    {
        // Set maximum distance so these entries sort to the end
        // Use the same sentinel value to maintain sorting stability
        _SplatSortDistances[idx] = origIdx;
    }
    else
    {
        float3 pos = LoadSplatPos(origIdx);
        pos = mul(_MatrixMV, float4(pos.xyz, 1)).xyz;

        // Create a deterministic sort key by encoding original index in lower bits
        // This ensures stable sorting for splats with similar depths
        uint distanceKey = FloatToSortableUint(pos.z);

        // Use lower 16 bits for original index to break ties deterministically
        // Shift distance to upper bits and add index in lower bits
        uint indexBits = origIdx & 0xFFFF; // Take lower 16 bits of original index
        distanceKey = (distanceKey & 0xFFFF0000) | indexBits;

        _SplatSortDistances[idx] = distanceKey;
    }
}

RWStructuredBuffer<SplatViewData> _SplatViewData;

float _SplatScale;
float _SplatOpacityScale;
uint _SHOrder;
uint _SHOnly;

// Frustum culling variables
uint _FrustumCullingEnabled;
float4 _FrustumPlanes[6]; // 6 frustum planes (xyz = normal, w = distance)
float _FrustumCullingTolerance;
float4x4 _MatrixVP; // View-Projection matrix
RWStructuredBuffer<uint> _ChunkVisibility; // per chunk: 0=hidden, 1=visible, 2=partial
RWStructuredBuffer<uint> _SplatVisibility; // per splat: 0=hidden, 1=visible
RWStructuredBuffer<uint> _VisibleIndices; // compacted visible splat indices
RWStructuredBuffer<uint> _StreamCompactTemp; // temp buffer for scan operations
RWStructuredBuffer<uint> _VisibleCount; // [0] = number of visible splats

// LOD system variables (LODGE paper)
struct LODLevel
{
    float distanceThreshold;    // d_l in paper - distance threshold for this LOD
    float startSplatIndex;      // start index (currently unused, all splats in all LODs)
    float splatCount;           // number of splats (currently unused)
    float smoothingFactor;      // s_d/f in paper - 3D smoothing filter factor
};

uint _LODEnabled;
StructuredBuffer<LODLevel> _LODLevels;
uint _LODLevelCount;
float _LODDistanceMultiplier;
float _LODTransitionRange;
uint _Use3DSmoothingFilter;
RWStructuredBuffer<float2> _SplatLODData; // per splat: (LOD level, opacity blend factor)
float _CameraDistance; // distance from camera to scene center
uint _LODCullingEnabled; // enable LOD-based culling to reduce rendered splats
uint _MaxRenderLODLevel; // maximum LOD level to render (0=only closest, 1=close+medium, etc.)

#define CHUNK_HIDDEN 0
#define CHUNK_VISIBLE 1
#define CHUNK_PARTIAL 2

RWByteAddressBuffer _SplatSelectedBits;
ByteAddressBuffer _SplatDeletedBits;
uint _SplatBitsValid;

void DecomposeCovariance(float3 cov2d, out float2 v1, out float2 v2)
{
    #if 0 // does not quite give the correct results?

    // https://jsfiddle.net/mattrossman/ehxmtgw6/
    // References:
    // - https://www.youtube.com/watch?v=e50Bj7jn9IQ
    // - https://en.wikipedia.org/wiki/Eigenvalue_algorithm#2%C3%972_matrices
    // - https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
    float a = cov2d.x;
    float b = cov2d.y;
    float d = cov2d.z;
    float det = a * d - b * b; // matrix is symmetric, so "c" is same as "b"
    float trace = a + d;

    float mean = 0.5 * trace;
    float dist = sqrt(mean * mean - det);

    float lambda1 = mean + dist; // 1st eigenvalue
    float lambda2 = mean - dist; // 2nd eigenvalue

    if (b == 0) {
        // https://twitter.com/the_ross_man/status/1706342719776551360
        if (a > d) v1 = float2(1, 0);
        else v1 = float2(0, 1);
    } else
        v1 = normalize(float2(b, d - lambda2));

    v1.y = -v1.y;
    // The 2nd eigenvector is just a 90 degree rotation of the first since Gaussian axes are orthogonal
    v2 = float2(v1.y, -v1.x);

    // scaling components
    v1 *= sqrt(lambda1);
    v2 *= sqrt(lambda2);

    float radius = 1.5;
    v1 *= radius;
    v2 *= radius;

    #else

    // same as in antimatter15/splat
    float diag1 = cov2d.x, diag2 = cov2d.z, offDiag = cov2d.y;
    float mid = 0.5f * (diag1 + diag2);
    float radius = length(float2((diag1 - diag2) / 2.0, offDiag));
    float lambda1 = mid + radius;
    float lambda2 = max(mid - radius, 0.1);
    float2 diagVec = normalize(float2(offDiag, lambda1 - diag1));
    diagVec.y = -diagVec.y;
    float maxSize = 4096.0;
    v1 = min(sqrt(2.0 * lambda1), maxSize) * diagVec;
    v2 = min(sqrt(2.0 * lambda2), maxSize) * float2(diagVec.y, -diagVec.x);

    #endif
}

[numthreads(GROUP_SIZE,1,1)]
void CSCalcViewData(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    SplatData splat = LoadSplatData(idx);
    SplatViewData view = (SplatViewData)0;

    float3 centerWorldPos = mul(_MatrixObjectToWorld, float4(splat.pos,1)).xyz;
    float4 centerClipPos = mul(UNITY_MATRIX_VP, float4(centerWorldPos, 1));
    half opacityScale = _SplatOpacityScale;
    float splatScale = _SplatScale;

    // Load LOD data for this splat (LOD level, opacity blend factor)
    float2 lodData = float2(0, 1.0);
    if (_LODEnabled && _LODLevelCount > 0)
    {
        lodData = _SplatLODData[idx];
    }
    int splatLODLevel = (int)lodData.x;
    float lodOpacityBlend = lodData.y;

    // deleted?
    if (_SplatBitsValid)
    {
        uint wordIdx = idx / 32;
        uint bitIdx = idx & 31;
        uint wordVal = _SplatDeletedBits.Load(wordIdx * 4);
        if (wordVal & (1 << bitIdx))
        {
            centerClipPos.w = 0;
        }
    }

    view.pos = centerClipPos;
    bool behindCam = centerClipPos.w <= 0;
    if (!behindCam)
    {
        float4 boxRot = splat.rot;
        float3 boxSize = splat.scale;

        float3x3 splatRotScaleMat = CalcMatrixFromRotationScale(boxRot, boxSize);

        float3 cov3d0, cov3d1;
        CalcCovariance3D(splatRotScaleMat, cov3d0, cov3d1);
        float splatScale2 = splatScale * splatScale;
        cov3d0 *= splatScale2;
        cov3d1 *= splatScale2;

        // Apply 3D smoothing filter based on LOD level (LODGE Equation 3)
        // G̃(x) = √(|Σ|/|Σ + (sd/f)·I|) × exp(-½(x-μ)ᵀ(Σ + (sd/f)·I)⁻¹(x-μ))
        // This adds (sd/f)·I to the covariance matrix to prevent aliasing at distance
        if (_LODEnabled && _Use3DSmoothingFilter && splatLODLevel > 0 && splatLODLevel < _LODLevelCount)
        {
            LODLevel currentLOD = _LODLevels[splatLODLevel];
            float smoothingFactor = currentLOD.smoothingFactor;

            // Add smoothing term to covariance (approximation: add to diagonal)
            // In practice, this increases the Gaussian's size to prevent aliasing
            float smoothing2 = smoothingFactor * smoothingFactor;
            cov3d0 += float3(smoothing2, 0, smoothing2); // Add to xx and zz components
            cov3d1 += float3(0, smoothing2, 0);          // Add to yy component
        }

        float3 cov2d = CalcCovariance2D(splat.pos, cov3d0, cov3d1, _MatrixMV, UNITY_MATRIX_P, _VecScreenParams);

        DecomposeCovariance(cov2d, view.axis1, view.axis2);

        float3 worldViewDir = _VecWorldSpaceCameraPos.xyz - centerWorldPos;
        float3 objViewDir = mul((float3x3)_MatrixWorldToObject, worldViewDir);
        objViewDir = normalize(objViewDir);

        half4 col;
        col.rgb = ShadeSH(splat.sh, objViewDir, _SHOrder, _SHOnly != 0);

        // Apply LOD opacity blending (LODGE Equation 4)
        // This creates smooth transitions between LOD levels
        col.a = min(splat.opacity * opacityScale * lodOpacityBlend, 65000);

        view.color.x = (f32tof16(col.r) << 16) | f32tof16(col.g);
        view.color.y = (f32tof16(col.b) << 16) | f32tof16(col.a);
    }

    _SplatViewData[idx] = view;
}


RWByteAddressBuffer _DstBuffer;
ByteAddressBuffer _SrcBuffer;
uint _BufferSize;

uint2 GetSplatIndicesFromWord(uint idx)
{
    uint idxStart = idx * 32;
    uint idxEnd = min(idxStart + 32, _SplatCount);
    return uint2(idxStart, idxEnd);
}

float3 ColorToSH0(float3 col)
{
    return (col - 0.5) / 0.2820948;
}
float InvSigmoid(float v)
{
    return log(v / max(1 - v, 1.0e-6));
}

// SH rotation
#include "SphericalHarmonics.hlsl"

void RotateSH(inout SplatSHData sh, float3x3 rot)
{
    float3 shin[16];
    float3 shout[16];
    shin[0] = sh.col;
    shin[1] = sh.sh1;
    shin[2] = sh.sh2;
    shin[3] = sh.sh3;
    shin[4] = sh.sh4;
    shin[5] = sh.sh5;
    shin[6] = sh.sh6;
    shin[7] = sh.sh7;
    shin[8] = sh.sh8;
    shin[9] = sh.sh9;
    shin[10] = sh.sh10;
    shin[11] = sh.sh11;
    shin[12] = sh.sh12;
    shin[13] = sh.sh13;
    shin[14] = sh.sh14;
    shin[15] = sh.sh15;
    RotateSH(rot, 4, shin, shout);
    sh.col = shout[0];
    sh.sh1 = shout[1];
    sh.sh2 = shout[2];
    sh.sh3 = shout[3];
    sh.sh4 = shout[4];
    sh.sh5 = shout[5];
    sh.sh6 = shout[6];
    sh.sh7 = shout[7];
    sh.sh8 = shout[8];
    sh.sh9 = shout[9];
    sh.sh10 = shout[10];
    sh.sh11 = shout[11];
    sh.sh12 = shout[12];
    sh.sh13 = shout[13];
    sh.sh14 = shout[14];
    sh.sh15 = shout[15];
}

float3x3 CalcSHRotMatrix(float4x4 objToWorld)
{
    float3x3 m = (float3x3)objToWorld;
    float sx = length(float3(m[0][0], m[0][1], m[0][2]));
    float sy = length(float3(m[1][0], m[1][1], m[1][2]));
    float sz = length(float3(m[2][0], m[2][1], m[2][2]));

    float invSX = 1.0 / sx;
    float invSY = 1.0 / sy;
    float invSZ = 1.0 / sz;

    m[0][0] *= invSX;
    m[0][1] *= invSX;
    m[0][2] *= invSX;
    m[1][0] *= invSY;
    m[1][1] *= invSY;
    m[1][2] *= invSY;
    m[2][0] *= invSZ;
    m[2][1] *= invSZ;
    m[2][2] *= invSZ;
    return m;
}


// ========== FRUSTUM CULLING KERNELS ==========
// Simplified approach: test each splat directly with a simple NDC bounds check

// Test if a splat is visible in the frustum
// Returns 1 if visible, 0 if hidden
uint TestSplatVisibility(uint splatIdx, float3 splatPosLocal)
{
    // Transform from local object space to world space, then to clip space
    float3 worldPos = mul(_MatrixObjectToWorld, float4(splatPosLocal, 1)).xyz;
    float4 clipPos = mul(_MatrixVP, float4(worldPos, 1));

    // Check if behind camera (w <= 0 means behind near plane)
    if (clipPos.w <= 0.0)
        return 0;

    // Perspective divide to get NDC coordinates
    float3 ndc = clipPos.xyz / clipPos.w;

    // Simple NDC bounds check with tolerance
    // In Unity with GPU projection matrix: x,y in [-1,1], z in [0,1] (DX) or [-1,1] (GL)
    // Use generous tolerance to avoid over-culling at edges
    float tolerance = _FrustumCullingTolerance;

    // Check if outside frustum
    if (ndc.x < -1.0 - tolerance || ndc.x > 1.0 + tolerance ||
        ndc.y < -1.0 - tolerance || ndc.y > 1.0 + tolerance ||
        ndc.z < -0.1 || ndc.z > 1.0 + tolerance)
    {
        return 0;
    }

    return 1;
}

// Kernel 1: Test all splats against frustum and LOD culling
[numthreads(GROUP_SIZE,1,1)]
void CSCullChunks(uint3 id : SV_DispatchThreadID)
{
    uint splatIdx = id.x;
    if (splatIdx >= _SplatCount)
        return;

    uint isVisible = 1;

    // Frustum culling
    if (_FrustumCullingEnabled)
    {
        float3 posLocal = LoadSplatPos(splatIdx);
        isVisible = TestSplatVisibility(splatIdx, posLocal);
    }

    // LOD culling (LODGE Equation 2) - only render splats at appropriate LOD level
    // This dramatically reduces rendered splats at distance
    if (_LODEnabled && _LODCullingEnabled && _LODLevelCount > 0 && isVisible == 1)
    {
        // Read LOD level assigned to this splat (computed in CSUpdateLODSelection)
        float2 lodData = _SplatLODData[splatIdx];
        int splatLODLevel = (int)lodData.x;
        float lodOpacity = lodData.y;

        // Cull splats with very low opacity (in transition zones)
        // This implements LODGE's distance-based selection
        if (lodOpacity < 0.01)
        {
            isVisible = 0;
        }

        // Additional culling: only render splats up to MaxRenderLODLevel
        // This prevents rendering distant low-detail splats when we have high detail nearby
        // MaxRenderLODLevel: 0 = only closest, 1 = close+medium, 2 = close+medium+far, etc.
        if (splatLODLevel > _MaxRenderLODLevel)
        {
            isVisible = 0;
        }
    }

    _SplatVisibility[splatIdx] = isVisible;
}

// Kernel 2: Direct stream compaction using atomic operations
// Much simpler and more robust than multi-level prefix sum
[numthreads(GROUP_SIZE,1,1)]
void CSCullSplatsInPartialChunks(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    // If this splat is visible, atomically allocate an output slot and write the index
    if (_SplatVisibility[idx] == 1)
    {
        uint outputIdx;
        InterlockedAdd(_VisibleCount[0], 1, outputIdx);
        _VisibleIndices[outputIdx] = idx;
    }
}

// Kernel 3: Initialize visible count to zero
[numthreads(1,1,1)]
void CSStreamCompactScan(uint3 id : SV_DispatchThreadID)
{
    _VisibleCount[0] = 0;
}

// Kernel 4: Copy visible indices to sort keys for sorting
// This prepares the visible splats for sorting by copying their indices
[numthreads(GROUP_SIZE,1,1)]
void CSStreamCompactWrite(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    // Get total visible count
    uint visibleCount = _VisibleCount[0];

    if (idx < visibleCount)
    {
        // Copy visible index to sort keys buffer
        // This will be used for sorting visible splats
        uint splatIdx = _VisibleIndices[idx];
        _SplatSortKeys[idx] = splatIdx;
    }
    else
    {
        // Fill remaining entries with sentinel values to sort to the end
        // Use deterministic pattern to ensure stable sorting behavior
        _SplatSortKeys[idx] = 0xFFFFFFF0 + (idx % 16);
    }
}


// ========== LOD (LEVEL OF DETAIL) KERNELS ==========
// Based on LODGE paper: https://arxiv.org/html/2505.23158v1

// Kernel: Update LOD selection based on camera distance (LODGE Equation 2)
// For each splat, determine which LOD level it belongs to and compute opacity blend factor
[numthreads(GROUP_SIZE,1,1)]
void CSUpdateLODSelection(uint3 id : SV_DispatchThreadID)
{
    uint splatIdx = id.x;
    if (splatIdx >= _SplatCount)
        return;

    // If LOD is disabled, set all splats to LOD 0 with full opacity
    if (!_LODEnabled || _LODLevelCount == 0)
    {
        _SplatLODData[splatIdx] = float2(0, 1.0);
        return;
    }

    // Load splat position in local object space
    float3 splatPosLocal = LoadSplatPos(splatIdx);

    // Transform to world space
    float3 splatPosWorld = mul(_MatrixObjectToWorld, float4(splatPosLocal, 1)).xyz;

    // Calculate distance from camera to this splat
    float splatDistance = length(_VecWorldSpaceCameraPos.xyz - splatPosWorld);

    // Apply global distance multiplier
    splatDistance *= _LODDistanceMultiplier;

    // Select LOD level based on distance thresholds (LODGE Equation 2)
    // Ĝ(c) = ⋃[l=0 to L-1] {gi ∈ G(l) : dl ≤ ||μi(l) - c||₂ < dl+1}
    int selectedLOD = 0;
    float opacityBlend = 1.0;

    for (uint l = 0; l < _LODLevelCount; l++)
    {
        LODLevel level = _LODLevels[l];

        if (splatDistance < level.distanceThreshold)
        {
            selectedLOD = l;

            // Calculate opacity blending for smooth transitions (LODGE Equation 4)
            // Blend between current and next LOD level within transition range
            if (l < _LODLevelCount - 1 && _LODTransitionRange > 0.0)
            {
                LODLevel nextLevel = _LODLevels[l + 1];
                float transitionStart = level.distanceThreshold - _LODTransitionRange;
                float transitionEnd = level.distanceThreshold;

                // Linear blend factor: 0 at transitionStart, 1 at transitionEnd
                float blendFactor = saturate((splatDistance - transitionStart) / _LODTransitionRange);

                // Fade out opacity as we approach next LOD level
                // This creates smooth transitions without popping
                opacityBlend = 1.0 - blendFactor * 0.5; // Fade to 50% at transition boundary
            }

            break;
        }
    }

    // If distance exceeds all thresholds, use the last LOD level
    if (splatDistance >= _LODLevels[_LODLevelCount - 1].distanceThreshold)
    {
        selectedLOD = _LODLevelCount - 1;
    }

    // Store LOD level and opacity blend factor for this splat
    _SplatLODData[splatIdx] = float2(selectedLOD, opacityBlend);
}

