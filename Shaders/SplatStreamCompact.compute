// SPDX-License-Identifier: MIT
// Stream compaction kernel - WebGPU compatible
// This kernel is separate to avoid dependencies on other buffers

#define GROUP_SIZE 1024

#pragma kernel CSCountVisibleSplats
#pragma kernel CSCopyVisibleCountToIndirectArgs
#pragma kernel CSCopyVisibleIndicesToSortKeys
#pragma kernel CSResetVisibleCount

// Only the buffers needed for this specific kernel
RWStructuredBuffer<uint> _SplatVisibility; // per splat: 0=hidden, 1=visible
RWStructuredBuffer<uint> _VisibleIndices; // compacted visible splat indices
RWStructuredBuffer<uint> _VisibleCount; // [0] = number of visible splats
RWStructuredBuffer<uint> _IndirectArgs; // [5] = indirect draw arguments
RWStructuredBuffer<uint> _SortKeys; // sort keys buffer (for copying visible indices)
uint _SplatCount;

// Kernel: Reset visible count (WebGPU compatible - separate dispatch)
[numthreads(1,1,1)]
void CSResetVisibleCount(uint3 id : SV_DispatchThreadID)
{
    _VisibleCount[0] = 0;
}

// Kernel: Count visible splats using atomic operations (WebGPU compatible)
[numthreads(GROUP_SIZE,1,1)]
void CSCountVisibleSplats(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    // No reset here - done in separate dispatch to avoid race condition
    // Atomic increment for each visible splat
    if (_SplatVisibility[idx] == 1)
    {
        uint originalValue;
        InterlockedAdd(_VisibleCount[0], 1, originalValue);

        // Also directly write to compacted indices buffer
        _VisibleIndices[originalValue] = idx;
    }
}

// Kernel: Copy visible count to indirect args instanceCount (position 1)
[numthreads(1,1,1)]
void CSCopyVisibleCountToIndirectArgs(uint3 id : SV_DispatchThreadID)
{
    // Copy _VisibleCount[0] to _IndirectArgs[1] (instanceCount)
    _IndirectArgs[1] = _VisibleCount[0];
}

// Kernel: Copy visible indices to sort keys buffer for sorting
[numthreads(GROUP_SIZE,1,1)]
void CSCopyVisibleIndicesToSortKeys(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _SplatCount)
        return;

    uint visibleCount = _VisibleCount[0];

    if (idx < visibleCount)
    {
        // Copy visible indices to sort keys buffer
        _SortKeys[idx] = _VisibleIndices[idx];
    }
    else
    {
        // Fill unused positions with deterministic sentinel values to avoid sorting instability
        // Use a deterministic pattern instead of a single value to ensure stable sorting
        _SortKeys[idx] = 0xFFFFFFF0 + (idx % 16); // Deterministic pattern for stable sorting
    }
}